#!/data/data/com.termux/files/usr/bin/bash
set -euo pipefail

RED="\033[1;31m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
RESET="\033[0m"

usage() {
    echo -e "${BLUE}Usage:${RESET} gh open [options] [<path>]" >&2
    echo
    echo -e "${YELLOW}Options:${RESET}"
    echo "  -r <remote>   Specify remote (default: tracking, origin, first)"
    echo "  -b <branch>   Specify branch or commit (default: current branch or HEAD)"
    echo "  -n            Dry-run (print URL only)"
    echo "  -v            Show version"
    echo "  -h            Show this help message"
    exit 1
}

version() {
    echo -e "${BLUE}gh-open v1.0${RESET}"
    echo -e "${YELLOW}by PhateValleyman${RESET}"
    echo -e "${YELLOW}Jonas.Ned@outlook.com${RESET}"
    exit 0
}

dry_run=false
remote_override=""
branch_override=""
while getopts ":r:b:nhv" opt; do
    case "$opt" in
        r) remote_override="$OPTARG" ;;
        b) branch_override="$OPTARG" ;;
        n) dry_run=true ;;
        v) version ;;
        h) usage ;;
        *) usage ;;
    esac
done
shift $((OPTIND -1))

target="${1:-.}"

if [ ! -e "$target" ]; then
    echo -e "${RED}Error:${RESET} Path '$target' does not exist." >&2
    exit 1
fi

# If inside repo, use current dir; otherwise try to locate Git repo from target path
if git -C "$target" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    repo_root=$(git -C "$target" rev-parse --show-toplevel)
else
    echo -e "${RED}Error:${RESET} Not in a Git repository and target is not inside one." >&2
    exit 1
fi

# Resolve absolute paths
abs_target=$(realpath -s "$target")
abs_repo_root=$(realpath -s "$repo_root")

case "$abs_target" in
    "$abs_repo_root"|"${abs_repo_root}"/*) ;;
    *)
        echo -e "${RED}Error:${RESET} '$target' is not within the repository." >&2
        exit 1
        ;;
esac

# Determine which remote to use
if [ -n "$remote_override" ]; then
    current_remote="$remote_override"
elif tracking=$(git -C "$repo_root" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null); then
    current_remote="${tracking%%/*}"
elif git -C "$repo_root" remote | grep -q '^origin$'; then
    current_remote="origin"
else
    current_remote=$(git -C "$repo_root" remote | head -n1)
fi

if [ -z "$current_remote" ] || ! git -C "$repo_root" remote get-url "$current_remote" >/dev/null 2>&1; then
    echo -e "${RED}Error:${RESET} No valid Git remote found." >&2
    exit 1
fi

remote_url=$(git -C "$repo_root" remote get-url "$current_remote")
case "$remote_url" in
    git@*)
        remote_url="https://${remote_url#git@}"
        remote_url="${remote_url/://}"
        remote_url="${remote_url%.git}"
        ;;
    *)
        remote_url="${remote_url%.git}"
        ;;
esac

# Determine branch/commit
if [ -n "$branch_override" ]; then
    branch_or_commit="$branch_override"
else
    branch_or_commit=$(git -C "$repo_root" symbolic-ref --short HEAD 2>/dev/null || git -C "$repo_root" rev-parse --short HEAD)
fi

# Get relative path from repo root
rel_path="${abs_target#$abs_repo_root/}"
if [ "$abs_target" = "$abs_repo_root" ]; then
    rel_path=""
fi

# Construct service-specific URL
case "$remote_url" in
    *github.com*)
        if [ -d "$abs_target" ]; then
            url="${remote_url}/tree/${branch_or_commit}/${rel_path}"
        elif [ -z "$rel_path" ]; then
            url="$remote_url"
        else
            url="${remote_url}/blob/${branch_or_commit}/${rel_path}"
        fi
        ;;
    *gitlab.com*)
        if [ -d "$abs_target" ]; then
            url="${remote_url}/-/tree/${branch_or_commit}/${rel_path}"
        elif [ -z "$rel_path" ]; then
            url="$remote_url"
        else
            url="${remote_url}/-/blob/${branch_or_commit}/${rel_path}"
        fi
        ;;
    *bitbucket.org*)
        if [ -z "$rel_path" ]; then
            url="$remote_url"
        else
            url="${remote_url}/src/${branch_or_commit}/${rel_path}"
        fi
        ;;
    *)
        if [ -d "$abs_target" ]; then
            url="${remote_url}/tree/${branch_or_commit}/${rel_path}"
        elif [ -z "$rel_path" ]; then
            url="$remote_url"
        else
            url="${remote_url}/blob/${branch_or_commit}/${rel_path}"
        fi
        ;;
esac

# Clean URL
url=$(echo "$url" | sed 's|\([^:]\)/\{2,\}|/|g')

# Output
echo -e "Using remote: ${YELLOW}${current_remote}${RESET}"
echo -e "Opening ${BLUE}${url}${RESET}"

if [ "$dry_run" = false ]; then
    xdg-open "$url" >/dev/null 2>&1 || open "$url" >/dev/null 2>&1
fi
